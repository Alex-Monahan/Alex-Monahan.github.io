{
  "version": 3,
  "sources": ["../src/bindings/connection.ts", "../src/utils/ipc_buffer.ts", "../src/status.ts", "../src/bindings/runtime.ts", "../src/bindings/file_stats.ts", "../src/flat_arrow.ts", "../src/bindings/bindings_base.ts", "../src/bindings/insert_options.ts", "../src/bindings/insert.ts", "../src/log.ts", "../src/parallel/async_connection.ts", "../src/parallel/worker_request.ts", "../src/parallel/async_bindings.ts", "../src/parallel/worker_dispatcher.ts", "../src/platform.ts", "../src/version.ts"],
  "sourcesContent": ["import * as arrow from 'apache-arrow';\nimport * as utils from '../utils';\nimport { DuckDBBindings } from './bindings_interface';\nimport { CSVInsertOptions, JSONInsertOptions, ArrowInsertOptions } from './insert_options';\n\n/** A thin helper to bind the connection id and talk record batches */\nexport class DuckDBConnection {\n    /** The bindings */\n    protected _bindings: DuckDBBindings;\n    /** The connection handle */\n    protected _conn: number;\n\n    /** Constructor */\n    constructor(bindings: DuckDBBindings, conn: number) {\n        this._bindings = bindings;\n        this._conn = conn;\n    }\n\n    /** Close a connection */\n    public close(): void {\n        this._bindings.disconnect(this._conn);\n    }\n\n    /** Brave souls may use this function to consume the underlying connection id */\n    public useUnsafe<R>(callback: (bindings: DuckDBBindings, conn: number) => R) {\n        return callback(this._bindings, this._conn);\n    }\n\n    /** Run a query */\n    public query<T extends { [key: string]: arrow.DataType } = any>(text: string): arrow.Table<T> {\n        const buffer = this._bindings.runQuery(this._conn, text);\n        const reader = arrow.RecordBatchReader.from<T>(buffer);\n        console.assert(reader.isSync());\n        console.assert(reader.isFile());\n        return arrow.Table.from(reader);\n    }\n\n    /** Send a query */\n    public send<T extends { [key: string]: arrow.DataType } = any>(text: string): arrow.RecordBatchStreamReader<T> {\n        const header = this._bindings.sendQuery(this._conn, text);\n        const iter = new ResultStreamIterator(this._bindings, this._conn, header);\n        const reader = arrow.RecordBatchReader.from<T>(iter);\n        console.assert(reader.isSync());\n        console.assert(reader.isStream());\n        return reader;\n    }\n\n    /** Create a prepared statement */\n    public prepare<T extends { [key: string]: arrow.DataType } = any>(text: string): PreparedStatement {\n        const stmt = this._bindings.createPrepared(this._conn, text);\n        return new PreparedStatement<T>(this._bindings, this._conn, stmt);\n    }\n\n    /** Insert arrow vectors */\n    public insertArrowVectors<T extends { [key: string]: arrow.Vector } = any>(\n        children: T,\n        options: ArrowInsertOptions,\n    ): void {\n        this.insertArrowTable(arrow.Table.new(children), options);\n    }\n    /** Insert an arrow table */\n    public insertArrowTable(table: arrow.Table, options: ArrowInsertOptions): void {\n        if (table.schema.fields.length == 0) {\n            console.warn(\n                'The schema is empty! If you used arrow.Table.from, consider constructing schema and batches manually',\n            );\n        }\n        this.insertArrowBatches(table.schema, table.chunks, options);\n    }\n    /** Insert record batches */\n    public insertArrowBatches(\n        schema: arrow.Schema,\n        batches: Iterable<arrow.RecordBatch>,\n        options: ArrowInsertOptions,\n    ): void {\n        /// Warn the user about an empty schema.\n        if (schema.fields.length == 0) {\n            console.warn(\n                'The schema is empty! If you used arrow.Table.from, consider constructing schema and batches manually',\n            );\n        }\n\n        // Prepare the IPC stream writer\n        const buffer = new utils.IPCBuffer();\n        const writer = new arrow.RecordBatchStreamWriter().reset(buffer, schema);\n\n        // Write all batches to the ipc buffer\n        let first = true;\n        for (const batch of batches) {\n            if (!first) {\n                this._bindings.insertArrowFromIPCStream(this._conn, buffer.flush(), options);\n            }\n            first = false;\n            writer.write(batch);\n        }\n        writer.finish();\n        this._bindings.insertArrowFromIPCStream(this._conn, buffer.flush(), options);\n    }\n    /** Insert an arrow table from an ipc stream */\n    public insertArrowFromIPCStream(buffer: Uint8Array, options: ArrowInsertOptions): void {\n        this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);\n    }\n\n    /** Inesrt csv file from path */\n    public insertCSVFromPath(path: string, options: CSVInsertOptions): void {\n        this._bindings.insertCSVFromPath(this._conn, path, options);\n    }\n    /** Insert json file from path */\n    public insertJSONFromPath(path: string, options: JSONInsertOptions): void {\n        this._bindings.insertJSONFromPath(this._conn, path, options);\n    }\n}\n\n/** A result stream iterator */\nexport class ResultStreamIterator implements Iterable<Uint8Array> {\n    /** First chunk? */\n    _first: boolean;\n    /** Reached end of stream? */\n    _depleted: boolean;\n\n    constructor(protected bindings: DuckDBBindings, protected conn: number, protected header: Uint8Array) {\n        this._first = true;\n        this._depleted = false;\n    }\n\n    next(): IteratorResult<Uint8Array> {\n        if (this._first) {\n            this._first = false;\n            return { done: false, value: this.header };\n        }\n        if (this._depleted) {\n            return { done: true, value: null };\n        }\n        const bufferI8 = this.bindings.fetchQueryResults(this.conn);\n        this._depleted = bufferI8.length == 0;\n        return {\n            done: this._depleted,\n            value: bufferI8,\n        };\n    }\n\n    [Symbol.iterator]() {\n        return this;\n    }\n}\n\n/** A thin helper to bind the prepared statement id*/\nexport class PreparedStatement<T extends { [key: string]: arrow.DataType } = any> {\n    /** The bindings */\n    protected readonly bindings: DuckDBBindings;\n    /** The connection id */\n    protected readonly connectionId: number;\n    /** The statement id */\n    protected readonly statementId: number;\n\n    /** Constructor */\n    constructor(bindings: DuckDBBindings, connectionId: number, statementId: number) {\n        this.bindings = bindings;\n        this.connectionId = connectionId;\n        this.statementId = statementId;\n    }\n\n    /** Close a prepared statement */\n    public close() {\n        this.bindings.closePrepared(this.connectionId, this.statementId);\n    }\n\n    /** Run a prepared statement */\n    public query(...params: any[]): arrow.Table<T> {\n        const buffer = this.bindings.runPrepared(this.connectionId, this.statementId, params);\n        const reader = arrow.RecordBatchReader.from<T>(buffer);\n        console.assert(reader.isSync());\n        console.assert(reader.isFile());\n        return arrow.Table.from(reader as arrow.RecordBatchFileReader);\n    }\n\n    /** Send a prepared statement */\n    public send(...params: any[]): arrow.RecordBatchStreamReader<T> {\n        const header = this.bindings.sendPrepared(this.connectionId, this.statementId, params);\n        const iter = new ResultStreamIterator(this.bindings, this.connectionId, header);\n        const reader = arrow.RecordBatchReader.from<T>(iter);\n        console.assert(reader.isSync());\n        console.assert(reader.isStream());\n        return reader as arrow.RecordBatchStreamReader;\n    }\n}\n", "import * as arrow from 'apache-arrow';\n\nexport class IPCBuffer extends arrow.AsyncByteQueue<Uint8Array> {\n    /// Flush the buffer\n    flush(): Uint8Array {\n        const buffer = super.toUint8Array(true);\n        this._values.length = 0;\n        return buffer;\n    }\n}\n", "export enum StatusCode {\n    SUCCESS = 0,\n}\n", "import { DuckDBModule } from './duckdb_module';\n\n/** Wrapper for TextDecoder to support shared array buffers */\nfunction TextDecoderWrapper(): (input?: BufferSource) => string {\n    const decoder = new TextDecoder();\n    return (data: any) => {\n        if (typeof SharedArrayBuffer !== 'undefined' && data.buffer instanceof SharedArrayBuffer) {\n            data = new Uint8Array(data);\n        }\n        return decoder.decode(data);\n    };\n}\n/** Helper to decode text */\nexport const decodeText = TextDecoderWrapper();\n\n/** Copy a buffer */\nexport function failWith(mod: DuckDBModule, msg: string): void {\n    mod.ccall('duckdb_web_fail_with', null, ['string'], [msg]);\n}\n\n/** Copy a buffer */\nexport function copyBuffer(mod: DuckDBModule, begin: number, length: number): Uint8Array {\n    const buffer = mod.HEAPU8.subarray(begin, begin + length);\n    const copy = new Uint8Array(new ArrayBuffer(buffer.byteLength));\n    copy.set(buffer);\n    return copy;\n}\n\n/** Decode a string */\nexport function readString(mod: DuckDBModule, begin: number, length: number): string {\n    return decodeText(mod.HEAPU8.subarray(begin, begin + length));\n}\n\n/** The data protocol */\nexport enum DuckDBDataProtocol {\n    BUFFER = 0,\n    NATIVE = 1,\n    HTTP = 3,\n}\n\n/** An info for a file registered with DuckDB */\nexport interface DuckDBFileInfo {\n    fileId: number;\n    fileName: string;\n    dataProtocol: DuckDBDataProtocol;\n    dataUrl: string | null;\n    dataNativeFd: number | null;\n    allowFullHttpReads?: boolean;\n}\n\n/** Call a function with packed response buffer */\nexport function callSRet(\n    mod: DuckDBModule,\n    funcName: string,\n    argTypes: Array<Emscripten.JSType>,\n    args: Array<any>,\n): [number, number, number] {\n    const stackPointer = mod.stackSave();\n\n    // Allocate the packed response buffer\n    const response = mod.stackAlloc(3 * 8);\n    argTypes.unshift('number');\n    args.unshift(response);\n\n    // Do the call\n    mod.ccall(funcName, null, argTypes, args);\n\n    // Read the response\n    const status = mod.HEAPF64[(response >> 3) + 0];\n    const data = mod.HEAPF64[(response >> 3) + 1];\n    const dataSize = mod.HEAPF64[(response >> 3) + 2];\n\n    // Restore the stack\n    mod.stackRestore(stackPointer);\n    return [status, data, dataSize];\n}\n\n/** Drop response buffers */\nexport function dropResponseBuffers(mod: DuckDBModule): void {\n    mod.ccall('duckdb_web_clear_response', null, [], []);\n}\n\n/** The duckdb runtime */\nexport interface DuckDBRuntime {\n    _files?: Map<string, any>;\n\n    // Test a platform feature\n    testPlatformFeature(mod: DuckDBModule, feature: number): boolean;\n\n    // File APIs with dedicated file identifier\n    openFile(mod: DuckDBModule, fileId: number): void;\n    syncFile(mod: DuckDBModule, fileId: number): void;\n    closeFile(mod: DuckDBModule, fileId: number): void;\n    getLastFileModificationTime(mod: DuckDBModule, fileId: number): number;\n    truncateFile(mod: DuckDBModule, fileId: number, newSize: number): void;\n    readFile(mod: DuckDBModule, fileId: number, buffer: number, bytes: number, location: number): number;\n    writeFile(mod: DuckDBModule, fileId: number, buffer: number, bytes: number, location: number): number;\n\n    // File APIs with path parameter\n    removeDirectory(mod: DuckDBModule, pathPtr: number, pathLen: number): void;\n    checkDirectory(mod: DuckDBModule, pathPtr: number, pathLen: number): boolean;\n    createDirectory(mod: DuckDBModule, pathPtr: number, pathLen: number): void;\n    listDirectoryEntries(mod: DuckDBModule, pathPtr: number, pathLen: number): boolean;\n    glob(mod: DuckDBModule, pathPtr: number, pathLen: number): void;\n    moveFile(mod: DuckDBModule, fromPtr: number, fromLen: number, toPtr: number, toLen: number): void;\n    checkFile(mod: DuckDBModule, pathPtr: number, pathLen: number): boolean;\n    removeFile(mod: DuckDBModule, pathPtr: number, pathLen: number): void;\n}\n\nexport const DEFAULT_RUNTIME: DuckDBRuntime = {\n    testPlatformFeature: (_mod: DuckDBModule, _feature: number): boolean => false,\n    openFile: (_mod: DuckDBModule, _fileId: number): void => {},\n    syncFile: (_mod: DuckDBModule, _fileId: number): void => {},\n    closeFile: (_mod: DuckDBModule, _fileId: number): void => {},\n    getLastFileModificationTime: (_mod: DuckDBModule, _fileId: number): number => {\n        return 0;\n    },\n    truncateFile: (_mod: DuckDBModule, _fileId: number, _newSize: number): void => {},\n    readFile: (_mod: DuckDBModule, _fileId: number, _buffer: number, _bytes: number, _location: number): number => {\n        return 0;\n    },\n    writeFile: (_mod: DuckDBModule, _fileId: number, _buffer: number, _bytes: number, _location: number): number => {\n        return 0;\n    },\n\n    removeDirectory: (_mod: DuckDBModule, _pathPtr: number, _pathLen: number): void => {},\n    checkDirectory: (_mod: DuckDBModule, _pathPtr: number, _pathLen: number): boolean => {\n        return false;\n    },\n    createDirectory: (_mod: DuckDBModule, _pathPtr: number, _pathLen: number): void => {},\n    listDirectoryEntries: (_mod: DuckDBModule, _pathPtr: number, _pathLen: number): boolean => {\n        return false;\n    },\n    glob: (_mod: DuckDBModule, _pathPtr: number, _pathLen: number): void => {},\n    moveFile: (_mod: DuckDBModule, _fromPtr: number, _fromLen: number, _toPtr: number, _toLen: number): void => {},\n    checkFile: (_mod: DuckDBModule, _pathPtr: number, _pathLen: number): boolean => {\n        return false;\n    },\n    removeFile: (_mod: DuckDBModule, _pathPtr: number, _pathLen: number): void => {},\n};\n", "export interface FileBlockStatistics {\n    /** The file reads cold */\n    file_reads_cold: number;\n    /** The file reads aheads */\n    file_reads_ahead: number;\n    /** The file reads cached */\n    file_reads_cached: number;\n    /** The file writes */\n    file_writes: number;\n    /** The page accesses */\n    page_accesses: number;\n    /** The page loads */\n    page_loads: number;\n}\n\n/** The file block statistics */\nexport class FileStatistics {\n    /** The cold file reads */\n    public totalFileReadsCold: number;\n    /** The file readaheads */\n    public totalFileReadsAhead: number;\n    /** The cached file reads */\n    public totalFileReadsCached: number;\n    /** The file writes */\n    public totalFileWrites: number;\n    /** The page accesses */\n    public totalPageAccesses: number;\n    /** The page loads */\n    public totalPageLoads: number;\n    /** The blocks */\n    public blockSize: number;\n    /** The blocks */\n    public blockStats: Uint8Array;\n\n    constructor(u8array: Uint8Array) {\n        const f64 = new Float64Array(u8array.buffer, u8array.byteOffset, u8array.byteLength / 8);\n        const blocks = new Uint8Array(new ArrayBuffer(u8array.byteLength));\n        blocks.set(u8array.subarray(7 * 8));\n        this.totalFileReadsCold = f64[0];\n        this.totalFileReadsAhead = f64[1];\n        this.totalFileReadsCached = f64[2];\n        this.totalFileWrites = f64[3];\n        this.totalPageAccesses = f64[4];\n        this.totalPageLoads = f64[5];\n        this.blockSize = f64[6];\n        this.blockStats = blocks;\n    }\n\n    /** The block stats */\n    public getBlockStats(index: number, out?: FileBlockStatistics): FileBlockStatistics {\n        out = out || {\n            file_reads_cold: 0,\n            file_reads_ahead: 0,\n            file_reads_cached: 0,\n            file_writes: 0,\n            page_accesses: 0,\n            page_loads: 0,\n        };\n        out.file_writes = this.blockStats[index * 3 + 0] & 0b1111;\n        out.file_reads_cold = this.blockStats[index * 3 + 0] >> 4;\n        out.file_reads_ahead = this.blockStats[index * 3 + 1] & 0b1111;\n        out.file_reads_cached = this.blockStats[index * 3 + 1] >> 4;\n        out.page_accesses = this.blockStats[index * 3 + 1] & 0b1111;\n        out.page_loads = this.blockStats[index * 3 + 1] >> 4;\n        return out;\n    }\n}\n", "import * as arrow from 'apache-arrow';\n\nexport interface FlatArrowType {\n    /// The type\n    type: string;\n    /// Is nullable?\n    nullable?: boolean;\n    /// Decimal precision\n    precision?: number;\n    /// Decimal scaling\n    scale?: number;\n    /// Timezone\n    timezone?: string;\n    /// Byte width (FixedSizeBinary)\n    byteWidth?: number;\n    /// Fields\n    children?: FlatArrowField[];\n}\n\nexport type FlatArrowField = FlatArrowType & { name: string };\n\nexport function flattenArrowField(name: string, type: arrow.DataType): FlatArrowField {\n    switch (type.typeId) {\n        case arrow.Type.Binary:\n            return { name, type: 'binary' };\n        case arrow.Type.Bool:\n            return { name, type: 'bool' };\n        case arrow.Type.Date:\n            return { name, type: 'date' };\n        case arrow.Type.DateDay:\n            return { name, type: 'date32[d]' };\n        case arrow.Type.DateMillisecond:\n            return { name, type: 'date64[ms]' };\n        case arrow.Type.Decimal: {\n            const dec = type as arrow.Decimal;\n            return { name, type: 'decimal', precision: dec.precision, scale: dec.scale };\n        }\n        case arrow.Type.Float:\n            return { name, type: 'float' };\n        case arrow.Type.Float16:\n            return { name, type: 'float16' };\n        case arrow.Type.Float32:\n            return { name, type: 'float32' };\n        case arrow.Type.Float64:\n            return { name, type: 'float64' };\n        case arrow.Type.Int:\n            return { name, type: 'int32' };\n        case arrow.Type.Int16:\n            return { name, type: 'int16' };\n        case arrow.Type.Int32:\n            return { name, type: 'int32' };\n        case arrow.Type.Int64:\n            return { name, type: 'int64' };\n        case arrow.Type.Uint16:\n            return { name, type: 'uint16' };\n        case arrow.Type.Uint32:\n            return { name, type: 'uint32' };\n        case arrow.Type.Uint64:\n            return { name, type: 'uint64' };\n        case arrow.Type.Uint8:\n            return { name, type: 'uint8' };\n        case arrow.Type.IntervalDayTime:\n            return { name, type: 'interval[dt]' };\n        case arrow.Type.IntervalYearMonth:\n            return { name, type: 'interval[m]' };\n        case arrow.Type.List: {\n            const list = type as arrow.List;\n            return { name, type: 'list', children: [flattenArrowField(list.valueField.name, list.valueField.type)] };\n        }\n        case arrow.Type.FixedSizeBinary: {\n            const bin = type as arrow.FixedSizeBinary;\n            return { name, type: 'fixedsizebinary', byteWidth: bin.byteWidth };\n        }\n        case arrow.Type.Null:\n            return { name, type: 'null' };\n        case arrow.Type.Utf8:\n            return { name, type: 'utf8' };\n        case arrow.Type.Struct: {\n            const struct_ = type as arrow.Struct;\n            return {\n                name,\n                type: 'struct',\n                children: struct_.children.map(c => flattenArrowField(c.name, c.type)),\n            };\n        }\n        case arrow.Type.Time:\n            return { name, type: 'time[s]' };\n        case arrow.Type.TimeMicrosecond:\n            return { name, type: 'time[us]' };\n        case arrow.Type.TimeMillisecond:\n            return { name, type: 'time[ms]' };\n        case arrow.Type.TimeNanosecond:\n            return { name, type: 'time[ns]' };\n        case arrow.Type.TimeSecond:\n            return { name, type: 'time[s]' };\n        case arrow.Type.Timestamp: {\n            const ts = type as arrow.Timestamp;\n            return { name, type: 'timestamp', timezone: ts.timezone || undefined };\n        }\n        case arrow.Type.TimestampSecond: {\n            const ts = type as arrow.TimestampSecond;\n            return { name, type: 'timestamp[s]', timezone: ts.timezone || undefined };\n        }\n        case arrow.Type.TimestampMicrosecond: {\n            const ts = type as arrow.TimestampMicrosecond;\n            return { name, type: 'timestamp[us]', timezone: ts.timezone || undefined };\n        }\n        case arrow.Type.TimestampNanosecond: {\n            const ts = type as arrow.TimestampNanosecond;\n            return { name, type: 'timestamp[ns]', timezone: ts.timezone || undefined };\n        }\n        case arrow.Type.TimestampMillisecond: {\n            const ts = type as arrow.TimestampMillisecond;\n            return { name, type: 'timestamp[ms]', timezone: ts.timezone || undefined };\n        }\n    }\n    throw new Error(`unsupported arrow type: ${type.toString()}`);\n}\n", "import { DuckDBModule, PThread } from './duckdb_module';\nimport { DuckDBConfig } from './config';\nimport { Logger } from '../log';\nimport { DuckDBBindings } from './bindings_interface';\nimport { DuckDBConnection } from './connection';\nimport { StatusCode } from '../status';\nimport { dropResponseBuffers, DuckDBRuntime, readString, callSRet, copyBuffer } from './runtime';\nimport { CSVInsertOptions, JSONInsertOptions, ArrowInsertOptions } from './insert_options';\nimport { ScriptTokens } from './tokens';\nimport { FileStatistics } from './file_stats';\nimport { flattenArrowField } from '../flat_arrow';\nimport { WebFile } from './web_file';\n\nconst TEXT_ENCODER = new TextEncoder();\n\ndeclare global {\n    // eslint-disable-next-line no-var\n    var DUCKDB_RUNTIME: any;\n}\n\n/** A DuckDB Feature */\nexport enum DuckDBFeature {\n    WASM_EXCEPTIONS = 1 << 0,\n    WASM_THREADS = 1 << 1,\n    WASM_SIMD = 1 << 2,\n    WASM_BULK_MEMORY = 1 << 3,\n    EMIT_BIGINT = 1 << 4,\n}\n\n/** The proxy for either the browser- order node-based DuckDB API */\nexport abstract class DuckDBBindingsBase implements DuckDBBindings {\n    /** The logger */\n    protected readonly _logger: Logger;\n    /** Backend-dependent native-glue code for DuckDB */\n    protected readonly _runtime: DuckDBRuntime;\n    /** The instance */\n    protected _instance: DuckDBModule | null = null;\n    /** The loading promise */\n    protected _initPromise: Promise<void> | null = null;\n    /** The resolver for the open promise (called by onRuntimeInitialized) */\n    protected _initPromiseResolver: () => void = () => {};\n\n    constructor(logger: Logger, runtime: DuckDBRuntime) {\n        this._logger = logger;\n        this._runtime = runtime;\n    }\n\n    /** Get the logger */\n    public get logger(): Logger {\n        return this._logger;\n    }\n    /** Get the instance */\n    public get mod(): DuckDBModule {\n        return this._instance!;\n    }\n    /** Get the instance */\n    public get pthread(): PThread | null {\n        return this.mod.PThread || null;\n    }\n\n    /** Instantiate the module */\n    protected abstract instantiateImpl(moduleOverrides: Partial<DuckDBModule>): Promise<DuckDBModule>;\n    /** Instantiate the database */\n    public async instantiate(): Promise<this> {\n        // Already opened?\n        if (this._instance != null) {\n            return this;\n        }\n        // Open in progress?\n        if (this._initPromise != null) {\n            await this._initPromise;\n        }\n\n        // Create a promise that we can await\n        this._initPromise = new Promise(resolve => {\n            this._initPromiseResolver = resolve;\n        });\n\n        // Initialize duckdb\n        this._instance = await this.instantiateImpl({\n            print: console.log.bind(console),\n            printErr: console.log.bind(console),\n            onRuntimeInitialized: this._initPromiseResolver,\n        });\n\n        // Wait for onRuntimeInitialized\n        await this._initPromise;\n        this._initPromise = null;\n\n        return this;\n    }\n    /** Open a database at a path */\n    public open(config: DuckDBConfig): void {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_open', ['string'], [JSON.stringify(config)]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        dropResponseBuffers(this.mod);\n    }\n\n    /** Reset the database */\n    public reset(): void {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_reset', [], []);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        dropResponseBuffers(this.mod);\n    }\n\n    /** Get the version */\n    public getVersion(): string {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_get_version', [], []);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        const version = readString(this.mod, d, n);\n        dropResponseBuffers(this.mod);\n        return version;\n    }\n    /** Get the feature flags */\n    public getFeatureFlags(): number {\n        return this.mod.ccall('duckdb_web_get_feature_flags', 'number', [], []);\n    }\n\n    /** Tokenize a script */\n    public tokenize(text: string): ScriptTokens {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_tokenize', ['string'], [text]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        const res = readString(this.mod, d, n);\n        dropResponseBuffers(this.mod);\n        return JSON.parse(res) as ScriptTokens;\n    }\n\n    /** Connect to database */\n    public connect(): DuckDBConnection {\n        const conn = this.mod.ccall('duckdb_web_connect', 'number', [], []);\n        return new DuckDBConnection(this, conn);\n    }\n    /** Disconnect from database */\n    public disconnect(conn: number): void {\n        this.mod.ccall('duckdb_web_disconnect', null, ['number'], [conn]);\n    }\n\n    /** Send a query and return the full result */\n    public runQuery(conn: number, text: string): Uint8Array {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_query_run', ['number', 'string'], [conn, text]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        const res = copyBuffer(this.mod, d, n);\n        dropResponseBuffers(this.mod);\n        return res;\n    }\n    /** Send a query asynchronously. Results have to be fetched with `fetchQueryResults` */\n    public sendQuery(conn: number, text: string): Uint8Array {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_query_send', ['number', 'string'], [conn, text]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        const res = copyBuffer(this.mod, d, n);\n        dropResponseBuffers(this.mod);\n        return res;\n    }\n    /** Fetch query results */\n    public fetchQueryResults(conn: number): Uint8Array {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_query_fetch_results', ['number'], [conn]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        const res = copyBuffer(this.mod, d, n);\n        dropResponseBuffers(this.mod);\n        return res;\n    }\n\n    /** Prepare a statement and return its identifier */\n    public createPrepared(conn: number, text: string): number {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_prepared_create', ['number', 'string'], [conn, text]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        dropResponseBuffers(this.mod);\n        return d;\n    }\n\n    /** Close a prepared statement */\n    public closePrepared(conn: number, statement: number): void {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_prepared_close', ['number', 'number'], [conn, statement]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        dropResponseBuffers(this.mod);\n    }\n\n    /** Execute a prepared statement and return the full result */\n    public runPrepared(conn: number, statement: number, params: any[]): Uint8Array {\n        const [s, d, n] = callSRet(\n            this.mod,\n            'duckdb_web_prepared_run',\n            ['number', 'number', 'string'],\n            [conn, statement, JSON.stringify(params)],\n        );\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        const res = copyBuffer(this.mod, d, n);\n        dropResponseBuffers(this.mod);\n        return res;\n    }\n\n    /** Execute a prepared statement and stream the result */\n    public sendPrepared(conn: number, statement: number, params: any[]): Uint8Array {\n        const [s, d, n] = callSRet(\n            this.mod,\n            'duckdb_web_prepared_send',\n            ['number', 'number', 'string'],\n            [conn, statement, JSON.stringify(params)],\n        );\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        const res = copyBuffer(this.mod, d, n);\n        dropResponseBuffers(this.mod);\n        return res;\n    }\n\n    /** Insert record batches from an arrow ipc stream */\n    public insertArrowFromIPCStream(conn: number, buffer: Uint8Array, options?: ArrowInsertOptions): void {\n        // Store buffer\n        const bufferPtr = this.mod._malloc(buffer.length);\n        const bufferOfs = this.mod.HEAPU8.subarray(bufferPtr, bufferPtr + buffer.length);\n        bufferOfs.set(buffer);\n        const optJSON = options ? JSON.stringify(options) : '';\n\n        // Call wasm function\n        const [s, d, n] = callSRet(\n            this.mod,\n            'duckdb_web_insert_arrow_from_ipc_stream',\n            ['number', 'number', 'number', 'string'],\n            [conn, bufferPtr, buffer.length, optJSON],\n        );\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n    }\n\n    /** Insert csv from path */\n    public insertCSVFromPath(conn: number, path: string, options: CSVInsertOptions): void {\n        // Stringify options\n        if (options.columns !== undefined) {\n            options.columnsFlat = [];\n            for (const k in options.columns) {\n                options.columnsFlat.push(flattenArrowField(k, options.columns[k]));\n            }\n        }\n        const opt = { ...options } as any;\n        opt.columns = opt.columnsFlat;\n        delete opt.columnsFlat;\n        const optJSON = JSON.stringify(opt);\n\n        // Call wasm function\n        const [s, d, n] = callSRet(\n            this.mod,\n            'duckdb_web_insert_csv_from_path',\n            ['number', 'string', 'string'],\n            [conn, path, optJSON],\n        );\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n    }\n    /** Insert json from path */\n    public insertJSONFromPath(conn: number, path: string, options: JSONInsertOptions): void {\n        // Stringify options\n        if (options.columns !== undefined) {\n            options.columnsFlat = [];\n            for (const k in options.columns) {\n                options.columnsFlat.push(flattenArrowField(k, options.columns[k]));\n            }\n        }\n        const opt = { ...options } as any;\n        opt.columns = opt.columnsFlat;\n        delete opt.columnsFlat;\n        const optJSON = JSON.stringify(opt);\n\n        // Call wasm function\n        const [s, d, n] = callSRet(\n            this.mod,\n            'duckdb_web_insert_json_from_path',\n            ['number', 'string', 'string'],\n            [conn, path, optJSON],\n        );\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n    }\n    /** Glob file infos */\n    public globFiles(path: string): WebFile[] {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_fs_glob_file_infos', ['string'], [path]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        const infoStr = readString(this.mod, d, n);\n        dropResponseBuffers(this.mod);\n        const info = JSON.parse(infoStr) as WebFile[];\n        if (info == null) {\n            return [];\n        }\n        return info;\n    }\n    /** Register a file object URL */\n    public registerFileURL(name: string, url?: string): void {\n        if (url === undefined) {\n            url = name;\n        }\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_fs_register_file_url', ['string', 'string'], [name, url]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        dropResponseBuffers(this.mod);\n    }\n    /** Register file text */\n    public registerFileText(name: string, text: string): void {\n        const buffer = TEXT_ENCODER.encode(text);\n        this.registerFileBuffer(name, buffer);\n    }\n    /** Register a file buffer */\n    public registerFileBuffer(name: string, buffer: Uint8Array): void {\n        const ptr = this.mod._malloc(buffer.length);\n        const dst = this.mod.HEAPU8.subarray(ptr, ptr + buffer.length);\n        dst.set(buffer);\n        const [s, d, n] = callSRet(\n            this.mod,\n            'duckdb_web_fs_register_file_buffer',\n            ['string', 'number', 'number'],\n            [name, ptr, buffer.length],\n        );\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        dropResponseBuffers(this.mod);\n    }\n    /** Register a file object URL */\n    public registerFileHandle<HandleType>(name: string, handle: HandleType): void {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_fs_register_file_url', ['string', 'string'], [name, name]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        dropResponseBuffers(this.mod);\n        globalThis.DUCKDB_RUNTIME._files = (globalThis.DUCKDB_RUNTIME._files || new Map()).set(name, handle);\n        if (this.pthread) {\n            for (const worker of this.pthread.runningWorkers) {\n                worker.postMessage({\n                    cmd: 'registerFileHandle',\n                    fileName: name,\n                    fileHandle: handle,\n                });\n            }\n            for (const worker of this.pthread.unusedWorkers) {\n                worker.postMessage({\n                    cmd: 'dropFileHandle',\n                    fileName: name,\n                });\n            }\n        }\n    }\n    /** Drop file */\n    public dropFile(name: string): boolean {\n        return this.mod.ccall('duckdb_web_fs_drop_file', 'boolean', ['string'], [name]);\n    }\n    /** Drop files */\n    public dropFiles(): void {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_fs_drop_files', [], []);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        dropResponseBuffers(this.mod);\n    }\n    /** Flush all files */\n    public flushFiles(): void {\n        this.mod.ccall('duckdb_web_flush_files', null, [], []);\n    }\n    /** Write a file to a path */\n    public copyFileToPath(name: string, path: string): void {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_copy_file_to_path', ['string', 'string'], [name, path]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        dropResponseBuffers(this.mod);\n    }\n    /** Write a file to a buffer */\n    public copyFileToBuffer(name: string): Uint8Array {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_copy_file_to_buffer', ['string'], [name]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        const buffer = this.mod.HEAPU8.subarray(d, d + n);\n        const copy = new Uint8Array(buffer.length);\n        copy.set(buffer);\n        dropResponseBuffers(this.mod);\n        return copy;\n    }\n\n    /** Enable tracking of file statistics */\n    public collectFileStatistics(file: string, enable: boolean): void {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_collect_file_stats', ['string', 'boolean'], [file, enable]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n    }\n    /** Export file statistics */\n    public exportFileStatistics(file: string): FileStatistics {\n        const [s, d, n] = callSRet(this.mod, 'duckdb_web_export_file_stats', ['string'], [file]);\n        if (s !== StatusCode.SUCCESS) {\n            throw new Error(readString(this.mod, d, n));\n        }\n        return new FileStatistics(this.mod.HEAPU8.subarray(d, d + n));\n    }\n}\n", "import * as arrow from 'apache-arrow';\nimport { FlatArrowField } from '../flat_arrow';\n\nexport enum JSONTableShape {\n    ROW_ARRAY = 'row-array',\n    COLUMN_OBJECT = 'column-object',\n}\n\nexport interface JSONInsertOptions {\n    name: string;\n    schema?: string;\n    create?: boolean;\n    shape?: JSONTableShape;\n    columns?: {\n        [key: string]: arrow.DataType;\n    };\n    columnsFlat?: FlatArrowField[];\n}\n\nexport interface CSVInsertOptions {\n    name: string;\n    schema?: string;\n    create?: boolean;\n    header?: boolean;\n    delimiter?: string;\n    quote?: string;\n    escape?: string;\n    skip?: number;\n    detect?: boolean;\n    dateFormat?: string;\n    timestampFormat?: string;\n    columns?: {\n        [key: string]: arrow.DataType;\n    };\n    columnsFlat?: FlatArrowField[];\n}\n\nexport interface ArrowInsertOptions {\n    name: string;\n    schema?: string;\n    create?: boolean;\n}\n", "export enum InsertMode {\n    APPEND,\n    IMPORT,\n}\n\nexport interface InsertOptions {\n    mode: InsertMode;\n}\n", "export enum LogLevel {\n    NONE = 0,\n    DEBUG = 1,\n    INFO = 2,\n    WARNING = 3,\n    ERROR = 4,\n}\n\nexport enum LogTopic {\n    NONE = 0,\n    CONNECT = 1,\n    DISCONNECT = 2,\n    OPEN = 3,\n    QUERY = 4,\n}\n\nexport enum LogEvent {\n    NONE = 0,\n    OK = 1,\n    ERROR = 2,\n    START = 3,\n    RUN = 4,\n    CAPTURE = 5,\n}\n\nexport enum LogOrigin {\n    NONE = 0,\n    WEB_WORKER = 1,\n    NODE_WORKER = 2,\n    BINDINGS = 3,\n    ASYNC_DUCKDB = 4,\n}\n\nexport type LogEntry<O, T, E, V> = {\n    readonly timestamp: Date;\n    readonly level: LogLevel;\n    readonly origin: O;\n    readonly topic: T;\n    readonly event: E;\n    readonly value: V;\n};\n\nexport type LogEntryVariant =\n    | LogEntry<LogOrigin.BINDINGS, LogTopic.QUERY, LogEvent.START, void>\n    | LogEntry<LogOrigin.BINDINGS, LogTopic.QUERY, LogEvent.OK, void>\n    | LogEntry<LogOrigin.BINDINGS, LogTopic.QUERY, LogEvent.ERROR, void>\n    | LogEntry<LogOrigin.BINDINGS, LogTopic.CONNECT, LogEvent.OK, void>\n    | LogEntry<LogOrigin.BINDINGS, LogTopic.CONNECT, LogEvent.ERROR, void>\n    | LogEntry<LogOrigin.BINDINGS, LogTopic.DISCONNECT, LogEvent.OK, void>\n    | LogEntry<LogOrigin.BINDINGS, LogTopic.DISCONNECT, LogEvent.ERROR, void>\n    | LogEntry<LogOrigin.BINDINGS, LogTopic.OPEN, LogEvent.START, void>\n    | LogEntry<LogOrigin.BINDINGS, LogTopic.OPEN, LogEvent.OK, void>\n    | LogEntry<LogOrigin.BINDINGS, LogTopic.OPEN, LogEvent.ERROR, void>\n    | LogEntry<LogOrigin.ASYNC_DUCKDB, LogTopic.QUERY, LogEvent.RUN, string>;\n\nexport interface Logger {\n    log(entry: LogEntryVariant): void;\n}\n\nexport class VoidLogger implements Logger {\n    public log(_entry: LogEntryVariant): void {}\n}\n\nexport class ConsoleLogger implements Logger {\n    public log(entry: LogEntryVariant): void {\n        console.log(entry);\n    }\n}\n\nexport function getLogLevelLabel(level: LogLevel): string {\n    switch (level) {\n        case LogLevel.NONE:\n            return 'NONE';\n        case LogLevel.DEBUG:\n            return 'DEBUG';\n        case LogLevel.INFO:\n            return 'INFO';\n        case LogLevel.WARNING:\n            return 'WARNING';\n        case LogLevel.ERROR:\n            return 'ERROR';\n        default:\n            return '?';\n    }\n}\n\nexport function getLogEventLabel(event: LogEvent): string {\n    switch (event) {\n        case LogEvent.NONE:\n            return 'NONE';\n        case LogEvent.OK:\n            return 'OK';\n        case LogEvent.ERROR:\n            return 'ERROR';\n        case LogEvent.START:\n            return 'START';\n        case LogEvent.RUN:\n            return 'RUN';\n        case LogEvent.CAPTURE:\n            return 'CAPTURE';\n        default:\n            return '?';\n    }\n}\n\nexport function getLogTopicLabel(topic: LogTopic): string {\n    switch (topic) {\n        case LogTopic.CONNECT:\n            return 'CONNECT';\n        case LogTopic.DISCONNECT:\n            return 'DISCONNECT';\n        case LogTopic.OPEN:\n            return 'OPEN';\n        case LogTopic.QUERY:\n            return 'QUERY';\n        default:\n            return '?';\n    }\n}\n\nexport function getLogOriginLabel(origin: LogOrigin): string {\n    switch (origin) {\n        case LogOrigin.NONE:\n            return 'NONE';\n        case LogOrigin.WEB_WORKER:\n            return 'WEB WORKER';\n        case LogOrigin.NODE_WORKER:\n            return 'NODE WORKER';\n        case LogOrigin.BINDINGS:\n            return 'DUCKDB BINDINGS';\n        case LogOrigin.ASYNC_DUCKDB:\n            return 'DUCKDB';\n        default:\n            return '?';\n    }\n}\n", "import * as arrow from 'apache-arrow';\nimport * as utils from '../utils';\nimport { AsyncDuckDB } from './async_bindings';\nimport { LogLevel, LogTopic, LogOrigin, LogEvent } from '../log';\nimport { ArrowInsertOptions, CSVInsertOptions, JSONInsertOptions } from '../bindings/insert_options';\n\n/** A thin helper to memoize the connection id */\nexport class AsyncDuckDBConnection {\n    /** The async duckdb */\n    protected readonly _bindings: AsyncDuckDB;\n    /** The conn handle */\n    protected readonly _conn: number;\n\n    constructor(bindings: AsyncDuckDB, conn: number) {\n        this._bindings = bindings;\n        this._conn = conn;\n    }\n\n    /** Access the database bindings */\n    public get bindings(): AsyncDuckDB {\n        return this._bindings;\n    }\n\n    /** Disconnect from the database */\n    public async close(): Promise<void> {\n        return this._bindings.disconnect(this._conn);\n    }\n\n    /** Brave souls may use this function to consume the underlying connection id */\n    public useUnsafe<R>(callback: (bindings: AsyncDuckDB, conn: number) => R) {\n        return callback(this._bindings, this._conn);\n    }\n\n    /** Run a query */\n    public async query<T extends { [key: string]: arrow.DataType } = any>(text: string): Promise<arrow.Table<T>> {\n        this._bindings.logger.log({\n            timestamp: new Date(),\n            level: LogLevel.INFO,\n            origin: LogOrigin.ASYNC_DUCKDB,\n            topic: LogTopic.QUERY,\n            event: LogEvent.RUN,\n            value: text,\n        });\n        const buffer = await this._bindings.runQuery(this._conn, text);\n        const reader = arrow.RecordBatchReader.from<T>(buffer);\n        console.assert(reader.isSync());\n        console.assert(reader.isFile());\n        return arrow.Table.from(reader as arrow.RecordBatchFileReader);\n    }\n\n    /** Send a query */\n    public async send<T extends { [key: string]: arrow.DataType } = any>(\n        text: string,\n    ): Promise<arrow.AsyncRecordBatchStreamReader<T>> {\n        this._bindings.logger.log({\n            timestamp: new Date(),\n            level: LogLevel.INFO,\n            origin: LogOrigin.ASYNC_DUCKDB,\n            topic: LogTopic.QUERY,\n            event: LogEvent.RUN,\n            value: text,\n        });\n        const header = await this._bindings.sendQuery(this._conn, text);\n        const iter = new AsyncResultStreamIterator(this._bindings, this._conn, header);\n        const reader = await arrow.RecordBatchReader.from<T>(iter);\n        console.assert(reader.isAsync());\n        console.assert(reader.isStream());\n        return reader as unknown as arrow.AsyncRecordBatchStreamReader<T>; // XXX\n    }\n\n    /** Create a prepared statement */\n    public async prepare<T extends { [key: string]: arrow.DataType } = any>(\n        text: string,\n    ): Promise<AsyncPreparedStatement> {\n        const stmt = await this._bindings.createPrepared(this._conn, text);\n        return new AsyncPreparedStatement<T>(this._bindings, this._conn, stmt);\n    }\n\n    /** Insert arrow vectors */\n    public async insertArrowVectors<T extends { [key: string]: arrow.Vector } = any>(\n        children: T,\n        options: ArrowInsertOptions,\n    ): Promise<void> {\n        await this.insertArrowTable(arrow.Table.new(children), options);\n    }\n    /** Insert an arrow table */\n    public async insertArrowTable(table: arrow.Table, options: ArrowInsertOptions): Promise<void> {\n        if (table.schema.fields.length == 0) {\n            console.warn(\n                'The schema is empty! If you used arrow.Table.from, consider constructing schema and batches manually',\n            );\n        }\n        await this.insertArrowBatches(table.schema, table.chunks, options);\n    }\n    /** Insert record batches */\n    public async insertArrowBatches(\n        schema: arrow.Schema,\n        batches: Iterable<arrow.RecordBatch>,\n        options: ArrowInsertOptions,\n    ): Promise<void> {\n        // Prepare the IPC stream writer\n        const buffer = new utils.IPCBuffer();\n        const writer = new arrow.RecordBatchStreamWriter().reset(buffer, schema);\n\n        // Write all batches to the ipc buffer\n        let first = true;\n        for (const batch of batches) {\n            if (!first) {\n                await this._bindings.insertArrowFromIPCStream(this._conn, buffer.flush(), options);\n            }\n            first = false;\n            writer.write(batch);\n        }\n        writer.finish();\n        await this._bindings.insertArrowFromIPCStream(this._conn, buffer.flush(), options);\n    }\n    /** Insert an arrow table from an ipc stream */\n    public async insertArrowFromIPCStream(buffer: Uint8Array, options: ArrowInsertOptions): Promise<void> {\n        await this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);\n    }\n\n    /** Insert csv file from path */\n    public async insertCSVFromPath(text: string, options: CSVInsertOptions): Promise<void> {\n        await this._bindings.insertCSVFromPath(this._conn, text, options);\n    }\n    /** Insert json file from path */\n    public async insertJSONFromPath(text: string, options: JSONInsertOptions): Promise<void> {\n        await this._bindings.insertJSONFromPath(this._conn, text, options);\n    }\n}\n\n/** An async result stream iterator */\nexport class AsyncResultStreamIterator implements AsyncIterable<Uint8Array> {\n    /** First chunk? */\n    protected _first: boolean;\n    /** Reached end of stream? */\n    protected _depleted: boolean;\n    /** In-flight */\n    protected _inFlight: Promise<Uint8Array> | null;\n\n    constructor(\n        protected readonly db: AsyncDuckDB,\n        protected readonly conn: number,\n        protected readonly header: Uint8Array,\n    ) {\n        this._first = true;\n        this._depleted = false;\n        this._inFlight = null;\n    }\n\n    async next(): Promise<IteratorResult<Uint8Array>> {\n        if (this._first) {\n            this._first = false;\n            return { done: false, value: this.header };\n        }\n        if (this._depleted) {\n            return { done: true, value: null };\n        }\n        let buffer: Uint8Array;\n        if (this._inFlight != null) {\n            buffer = await this._inFlight;\n            this._inFlight = null;\n        } else {\n            buffer = await this.db.fetchQueryResults(this.conn);\n        }\n        this._depleted = buffer.length == 0;\n        if (!this._depleted) {\n            this._inFlight = this.db.fetchQueryResults(this.conn);\n        }\n        return {\n            done: this._depleted,\n            value: buffer,\n        };\n    }\n\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n}\n\n/** A thin helper to bind the prepared statement id */\nexport class AsyncPreparedStatement<T extends { [key: string]: arrow.DataType } = any> {\n    /** The bindings */\n    protected readonly bindings: AsyncDuckDB;\n    /** The connection id */\n    protected readonly connectionId: number;\n    /** The statement id */\n    protected readonly statementId: number;\n\n    /** Constructor */\n    constructor(bindings: AsyncDuckDB, connectionId: number, statementId: number) {\n        this.bindings = bindings;\n        this.connectionId = connectionId;\n        this.statementId = statementId;\n    }\n\n    /** Close a prepared statement */\n    public async close() {\n        await this.bindings.closePrepared(this.connectionId, this.statementId);\n    }\n\n    /** Run a prepared statement */\n    public async query(...params: any[]): Promise<arrow.Table<T>> {\n        const buffer = await this.bindings.runPrepared(this.connectionId, this.statementId, params);\n        const reader = arrow.RecordBatchReader.from<T>(buffer);\n        console.assert(reader.isSync());\n        console.assert(reader.isFile());\n        return arrow.Table.from(reader as arrow.RecordBatchFileReader);\n    }\n\n    /** Send a prepared statement */\n    public async send(...params: any[]): Promise<arrow.AsyncRecordBatchStreamReader<T>> {\n        const header = await this.bindings.sendPrepared(this.connectionId, this.statementId, params);\n        const iter = new AsyncResultStreamIterator(this.bindings, this.connectionId, header);\n        const reader = await arrow.RecordBatchReader.from<T>(iter);\n        console.assert(reader.isAsync());\n        console.assert(reader.isStream());\n        return reader as unknown as arrow.AsyncRecordBatchStreamReader<T>; // XXX\n    }\n}\n", "import { CSVInsertOptions, JSONInsertOptions, ArrowInsertOptions } from '../bindings/insert_options';\nimport { LogEntryVariant } from '../log';\nimport { ScriptTokens } from '../bindings/tokens';\nimport { FileStatistics } from '../bindings/file_stats';\nimport { DuckDBConfig } from '../bindings/config';\nimport { WebFile } from '../bindings/web_file';\n\nexport type ConnectionID = number;\nexport type StatementID = number;\n\nexport enum WorkerRequestType {\n    CLOSE_PREPARED = 'CLOSE_PREPARED',\n    COLLECT_FILE_STATISTICS = 'COLLECT_FILE_STATISTICS',\n    CONNECT = 'CONNECT',\n    COPY_FILE_TO_BUFFER = 'COPY_FILE_TO_BUFFER',\n    COPY_FILE_TO_PATH = 'COPY_FILE_TO_PATH',\n    CREATE_PREPARED = 'CREATE_PREPARED',\n    DISCONNECT = 'DISCONNECT',\n    DROP_FILE = 'DROP_FILE',\n    DROP_FILES = 'DROP_FILES',\n    EXPORT_FILE_STATISTICS = 'EXPORT_FILE_STATISTICS',\n    FETCH_QUERY_RESULTS = 'FETCH_QUERY_RESULTS',\n    FLUSH_FILES = 'FLUSH_FILES',\n    GET_FEATURE_FLAGS = 'GET_FEATURE_FLAGS',\n    GET_VERSION = 'GET_VERSION',\n    GLOB_FILE_INFOS = 'GLOB_FILE_INFOS',\n    INSERT_ARROW_FROM_IPC_STREAM = 'INSERT_ARROW_FROM_IPC_STREAM',\n    INSERT_CSV_FROM_PATH = 'IMPORT_CSV_FROM_PATH',\n    INSERT_JSON_FROM_PATH = 'IMPORT_JSON_FROM_PATH',\n    INSTANTIATE = 'INSTANTIATE',\n    OPEN = 'OPEN',\n    PING = 'PING',\n    REGISTER_FILE_BUFFER = 'REGISTER_FILE_BUFFER',\n    REGISTER_FILE_HANDLE = 'REGISTER_FILE_HANDLE',\n    REGISTER_FILE_URL = 'REGISTER_FILE_URL',\n    RESET = 'RESET',\n    RUN_PREPARED = 'RUN_PREPARED',\n    RUN_QUERY = 'RUN_QUERY',\n    SEND_PREPARED = 'SEND_PREPARED',\n    SEND_QUERY = 'SEND_QUERY',\n    TOKENIZE = 'TOKENIZE',\n}\n\nexport enum WorkerResponseType {\n    CONNECTION_INFO = 'CONNECTION_INFO',\n    ERROR = 'ERROR',\n    FEATURE_FLAGS = 'FEATURE_FLAGS',\n    FILE_BUFFER = 'FILE_BUFFER',\n    FILE_INFOS = 'FILE_INFOS',\n    FILE_SIZE = 'FILE_SIZE',\n    FILE_STATISTICS = 'FILE_STATISTICS',\n    LOG = 'LOG',\n    OK = 'OK',\n    PREPARED_STATEMENT_ID = 'PREPARED_STATEMENT_ID',\n    QUERY_PLAN = 'QUERY_PLAN',\n    QUERY_RESULT = 'QUERY_RESULT',\n    QUERY_RESULT_CHUNK = 'QUERY_RESULT_CHUNK',\n    QUERY_START = 'QUERY_START',\n    REGISTERED_FILE = 'REGISTERED_FILE',\n    SCRIPT_TOKENS = 'SCRIPT_TOKENS',\n    SUCCESS = 'SUCCESS',\n    VERSION_STRING = 'VERSION_STRING',\n}\n\nexport type WorkerRequest<T, P> = {\n    readonly messageId: number;\n    readonly type: T;\n    readonly data: P;\n};\n\nexport type WorkerResponse<T, P> = {\n    readonly messageId: number;\n    readonly requestId: number;\n    readonly type: T;\n    readonly data: P;\n};\n\nexport type WorkerTaskReturnType<T extends WorkerTaskVariant> = T extends WorkerTask<any, any, infer P> ? P : never;\n\nexport class WorkerTask<T, D, P> {\n    readonly type: T;\n    readonly data: D;\n    promise: Promise<P>;\n    promiseResolver: (value: P | PromiseLike<P>) => void = () => {};\n    promiseRejecter: (value: any) => void = () => {};\n\n    constructor(type: T, data: D) {\n        this.type = type;\n        this.data = data;\n        this.promise = new Promise<P>(\n            (resolve: (value: P | PromiseLike<P>) => void, reject: (reason?: void) => void) => {\n                this.promiseResolver = resolve;\n                this.promiseRejecter = reject;\n            },\n        );\n    }\n}\n\nexport type WorkerRequestVariant =\n    | WorkerRequest<WorkerRequestType.CLOSE_PREPARED, [ConnectionID, StatementID]>\n    | WorkerRequest<WorkerRequestType.COLLECT_FILE_STATISTICS, [string, boolean]>\n    | WorkerRequest<WorkerRequestType.CONNECT, null>\n    | WorkerRequest<WorkerRequestType.COPY_FILE_TO_BUFFER, string>\n    | WorkerRequest<WorkerRequestType.COPY_FILE_TO_PATH, [string, string]>\n    | WorkerRequest<WorkerRequestType.CREATE_PREPARED, [ConnectionID, string]>\n    | WorkerRequest<WorkerRequestType.DISCONNECT, number>\n    | WorkerRequest<WorkerRequestType.DROP_FILE, string>\n    | WorkerRequest<WorkerRequestType.DROP_FILES, null>\n    | WorkerRequest<WorkerRequestType.EXPORT_FILE_STATISTICS, string>\n    | WorkerRequest<WorkerRequestType.FETCH_QUERY_RESULTS, number>\n    | WorkerRequest<WorkerRequestType.FLUSH_FILES, null>\n    | WorkerRequest<WorkerRequestType.GET_FEATURE_FLAGS, null>\n    | WorkerRequest<WorkerRequestType.GET_VERSION, null>\n    | WorkerRequest<\n          WorkerRequestType.INSERT_ARROW_FROM_IPC_STREAM,\n          [number, Uint8Array, ArrowInsertOptions | undefined]\n      >\n    | WorkerRequest<WorkerRequestType.INSERT_CSV_FROM_PATH, [number, string, CSVInsertOptions]>\n    | WorkerRequest<WorkerRequestType.INSERT_JSON_FROM_PATH, [number, string, JSONInsertOptions]>\n    | WorkerRequest<WorkerRequestType.INSTANTIATE, [string, string | null]>\n    | WorkerRequest<WorkerRequestType.OPEN, DuckDBConfig>\n    | WorkerRequest<WorkerRequestType.PING, null>\n    | WorkerRequest<WorkerRequestType.REGISTER_FILE_BUFFER, [string, Uint8Array]>\n    | WorkerRequest<WorkerRequestType.REGISTER_FILE_HANDLE, [string, any]>\n    | WorkerRequest<WorkerRequestType.REGISTER_FILE_URL, [string, string]>\n    | WorkerRequest<WorkerRequestType.GLOB_FILE_INFOS, string>\n    | WorkerRequest<WorkerRequestType.RESET, null>\n    | WorkerRequest<WorkerRequestType.RUN_PREPARED, [number, number, any[]]>\n    | WorkerRequest<WorkerRequestType.RUN_QUERY, [number, string]>\n    | WorkerRequest<WorkerRequestType.SEND_PREPARED, [number, number, any[]]>\n    | WorkerRequest<WorkerRequestType.SEND_QUERY, [number, string]>\n    | WorkerRequest<WorkerRequestType.TOKENIZE, string>;\n\nexport type WorkerResponseVariant =\n    | WorkerResponse<WorkerResponseType.CONNECTION_INFO, number>\n    | WorkerResponse<WorkerResponseType.ERROR, any>\n    | WorkerResponse<WorkerResponseType.FEATURE_FLAGS, number>\n    | WorkerResponse<WorkerResponseType.FILE_BUFFER, Uint8Array>\n    | WorkerResponse<WorkerResponseType.FILE_INFOS, WebFile[]>\n    | WorkerResponse<WorkerResponseType.FILE_SIZE, number>\n    | WorkerResponse<WorkerResponseType.FILE_STATISTICS, FileStatistics>\n    | WorkerResponse<WorkerResponseType.LOG, LogEntryVariant>\n    | WorkerResponse<WorkerResponseType.OK, null>\n    | WorkerResponse<WorkerResponseType.PREPARED_STATEMENT_ID, number>\n    | WorkerResponse<WorkerResponseType.QUERY_PLAN, Uint8Array>\n    | WorkerResponse<WorkerResponseType.QUERY_RESULT, Uint8Array>\n    | WorkerResponse<WorkerResponseType.QUERY_RESULT_CHUNK, Uint8Array>\n    | WorkerResponse<WorkerResponseType.QUERY_START, Uint8Array>\n    | WorkerResponse<WorkerResponseType.SCRIPT_TOKENS, ScriptTokens>\n    | WorkerResponse<WorkerResponseType.SUCCESS, boolean>\n    | WorkerResponse<WorkerResponseType.VERSION_STRING, string>;\n\nexport type WorkerTaskVariant =\n    | WorkerTask<WorkerRequestType.COLLECT_FILE_STATISTICS, [string, boolean], null>\n    | WorkerTask<WorkerRequestType.CLOSE_PREPARED, [number, number], null>\n    | WorkerTask<WorkerRequestType.CONNECT, null, ConnectionID>\n    | WorkerTask<WorkerRequestType.COPY_FILE_TO_BUFFER, string, Uint8Array>\n    | WorkerTask<WorkerRequestType.COPY_FILE_TO_PATH, [string, string], null>\n    | WorkerTask<WorkerRequestType.CREATE_PREPARED, [number, string], number>\n    | WorkerTask<WorkerRequestType.DISCONNECT, ConnectionID, null>\n    | WorkerTask<WorkerRequestType.DROP_FILE, string, boolean>\n    | WorkerTask<WorkerRequestType.DROP_FILES, null, null>\n    | WorkerTask<WorkerRequestType.EXPORT_FILE_STATISTICS, string, FileStatistics>\n    | WorkerTask<WorkerRequestType.FETCH_QUERY_RESULTS, ConnectionID, Uint8Array>\n    | WorkerTask<WorkerRequestType.FLUSH_FILES, null, null>\n    | WorkerTask<WorkerRequestType.GET_FEATURE_FLAGS, null, number>\n    | WorkerTask<WorkerRequestType.GET_VERSION, null, string>\n    | WorkerTask<\n          WorkerRequestType.INSERT_ARROW_FROM_IPC_STREAM,\n          [number, Uint8Array, ArrowInsertOptions | undefined],\n          null\n      >\n    | WorkerTask<WorkerRequestType.INSERT_CSV_FROM_PATH, [number, string, CSVInsertOptions], null>\n    | WorkerTask<WorkerRequestType.INSERT_JSON_FROM_PATH, [number, string, JSONInsertOptions], null>\n    | WorkerTask<WorkerRequestType.INSTANTIATE, [string, string | null], null>\n    | WorkerTask<WorkerRequestType.OPEN, DuckDBConfig, null>\n    | WorkerTask<WorkerRequestType.PING, null, null>\n    | WorkerTask<WorkerRequestType.REGISTER_FILE_BUFFER, [string, Uint8Array], null>\n    | WorkerTask<WorkerRequestType.REGISTER_FILE_HANDLE, [string, any], null>\n    | WorkerTask<WorkerRequestType.REGISTER_FILE_URL, [string, string], null>\n    | WorkerTask<WorkerRequestType.GLOB_FILE_INFOS, string, WebFile[]>\n    | WorkerTask<WorkerRequestType.RESET, null, null>\n    | WorkerTask<WorkerRequestType.RUN_PREPARED, [number, number, any[]], Uint8Array>\n    | WorkerTask<WorkerRequestType.RUN_QUERY, [ConnectionID, string], Uint8Array>\n    | WorkerTask<WorkerRequestType.SEND_PREPARED, [number, number, any[]], Uint8Array>\n    | WorkerTask<WorkerRequestType.SEND_QUERY, [ConnectionID, string], Uint8Array>\n    | WorkerTask<WorkerRequestType.TOKENIZE, string, ScriptTokens>;\n", "import {\n    WorkerRequestType,\n    WorkerResponseType,\n    WorkerResponseVariant,\n    WorkerTaskVariant,\n    WorkerTask,\n    ConnectionID,\n    WorkerTaskReturnType,\n} from './worker_request';\nimport { AsyncDuckDBBindings } from './async_bindings_interface';\nimport { Logger } from '../log';\nimport { AsyncDuckDBConnection } from './async_connection';\nimport { CSVInsertOptions, JSONInsertOptions, ArrowInsertOptions } from '../bindings/insert_options';\nimport { ScriptTokens } from '../bindings/tokens';\nimport { FileStatistics } from '../bindings/file_stats';\nimport { DuckDBConfig } from '../bindings/config';\nimport { flattenArrowField } from '../flat_arrow';\nimport { WebFile } from '../bindings/web_file';\n\nconst TEXT_ENCODER = new TextEncoder();\n\nexport class AsyncDuckDB implements AsyncDuckDBBindings {\n    /** The message handler */\n    protected readonly _onMessageHandler: (event: MessageEvent) => void;\n    /** The error handler */\n    protected readonly _onErrorHandler: (event: ErrorEvent) => void;\n    /** The close handler */\n    protected readonly _onCloseHandler: () => void;\n\n    /** The logger */\n    protected readonly _logger: Logger;\n    /** The worker */\n    protected _worker: Worker | null = null;\n    /** The promise for the worker shutdown */\n    protected _workerShutdownPromise: Promise<null> | null = null;\n    /** Make the worker as terminated */\n    protected _workerShutdownResolver: (value: PromiseLike<null> | null) => void = () => {};\n\n    /** The next message id */\n    protected _nextMessageId = 0;\n    /** The pending requests */\n    protected _pendingRequests: Map<number, WorkerTaskVariant> = new Map();\n\n    constructor(logger: Logger, worker: Worker | null = null) {\n        this._logger = logger;\n        this._onMessageHandler = this.onMessage.bind(this);\n        this._onErrorHandler = this.onError.bind(this);\n        this._onCloseHandler = this.onClose.bind(this);\n        if (worker != null) this.attach(worker);\n    }\n\n    /** Get the logger */\n    public get logger(): Logger {\n        return this._logger;\n    }\n\n    /** Attach to worker */\n    protected attach(worker: Worker): void {\n        this._worker = worker;\n        this._worker.addEventListener('message', this._onMessageHandler);\n        this._worker.addEventListener('error', this._onErrorHandler);\n        this._worker.addEventListener('close', this._onCloseHandler);\n        this._workerShutdownPromise = new Promise<null>(\n            (resolve: (value: PromiseLike<null> | null) => void, _reject: (reason?: void) => void) => {\n                this._workerShutdownResolver = resolve;\n            },\n        );\n    }\n\n    /** Detach from worker */\n    public detach(): void {\n        if (!this._worker) return;\n        this._worker.removeEventListener('message', this._onMessageHandler);\n        this._worker.removeEventListener('error', this._onErrorHandler);\n        this._worker.removeEventListener('close', this._onCloseHandler);\n        this._worker = null;\n        this._workerShutdownResolver(null);\n        this._workerShutdownPromise = null;\n        this._workerShutdownResolver = () => {};\n    }\n\n    /** Kill the worker */\n    public async terminate(): Promise<void> {\n        if (!this._worker) return;\n        this._worker.terminate();\n        //await this._workerShutdownPromise; TODO deadlocking in karma?\n        this._worker = null;\n        this._workerShutdownPromise = null;\n        this._workerShutdownResolver = () => {};\n    }\n\n    /** Post a task */\n    protected async postTask<W extends WorkerTaskVariant>(\n        task: W,\n        transfer: ArrayBuffer[] = [],\n    ): Promise<WorkerTaskReturnType<W>> {\n        if (!this._worker) {\n            console.error('cannot send a message since the worker is not set!');\n            return undefined as any;\n        }\n        const mid = this._nextMessageId++;\n        this._pendingRequests.set(mid, task);\n        this._worker.postMessage({\n            messageId: mid,\n            type: task.type,\n            data: task.data,\n        });\n        return (await task.promise) as WorkerTaskReturnType<W>;\n    }\n\n    /** Received a message */\n    protected onMessage(event: MessageEvent): void {\n        const response = event.data as WorkerResponseVariant;\n\n        // Short-circuit unassociated log entries\n        if (response.type == WorkerResponseType.LOG) {\n            this._logger.log(response.data);\n        }\n\n        // Get associated task\n        const task = this._pendingRequests.get(response.requestId);\n        if (!task) {\n            console.warn(`unassociated response: [${response.requestId}, ${response.type.toString()}]`);\n            return;\n        }\n        this._pendingRequests.delete(response.requestId);\n\n        // Request failed?\n        if (response.type == WorkerResponseType.ERROR) {\n            // Workaround for Firefox not being able to perform structured-clone on Native Errors\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1556604\n            const e = new Error(response.data.message);\n            e.name = response.data.name;\n            e.stack = response.data.stack;\n\n            task.promiseRejecter(e);\n            return;\n        }\n\n        // Otherwise differentiate between the tasks first\n        switch (task.type) {\n            case WorkerRequestType.CLOSE_PREPARED:\n            case WorkerRequestType.COLLECT_FILE_STATISTICS:\n            case WorkerRequestType.COPY_FILE_TO_PATH:\n            case WorkerRequestType.DISCONNECT:\n            case WorkerRequestType.DROP_FILES:\n            case WorkerRequestType.FLUSH_FILES:\n            case WorkerRequestType.INSERT_ARROW_FROM_IPC_STREAM:\n            case WorkerRequestType.INSERT_CSV_FROM_PATH:\n            case WorkerRequestType.INSERT_JSON_FROM_PATH:\n            case WorkerRequestType.INSTANTIATE:\n            case WorkerRequestType.OPEN:\n            case WorkerRequestType.PING:\n            case WorkerRequestType.REGISTER_FILE_BUFFER:\n            case WorkerRequestType.REGISTER_FILE_HANDLE:\n            case WorkerRequestType.REGISTER_FILE_URL:\n            case WorkerRequestType.RESET:\n                if (response.type == WorkerResponseType.OK) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.GLOB_FILE_INFOS:\n                if (response.type == WorkerResponseType.FILE_INFOS) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.GET_VERSION:\n                if (response.type == WorkerResponseType.VERSION_STRING) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.GET_FEATURE_FLAGS:\n                if (response.type == WorkerResponseType.FEATURE_FLAGS) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.TOKENIZE:\n                if (response.type == WorkerResponseType.SCRIPT_TOKENS) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.DROP_FILE:\n                if (response.type == WorkerResponseType.SUCCESS) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.COPY_FILE_TO_BUFFER:\n                if (response.type == WorkerResponseType.FILE_BUFFER) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.EXPORT_FILE_STATISTICS:\n                if (response.type == WorkerResponseType.FILE_STATISTICS) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.CONNECT:\n                if (response.type == WorkerResponseType.CONNECTION_INFO) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.RUN_PREPARED:\n            case WorkerRequestType.RUN_QUERY:\n                if (response.type == WorkerResponseType.QUERY_RESULT) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.SEND_PREPARED:\n            case WorkerRequestType.SEND_QUERY:\n                if (response.type == WorkerResponseType.QUERY_START) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.FETCH_QUERY_RESULTS:\n                if (response.type == WorkerResponseType.QUERY_RESULT_CHUNK) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n            case WorkerRequestType.CREATE_PREPARED:\n                if (response.type == WorkerResponseType.PREPARED_STATEMENT_ID) {\n                    task.promiseResolver(response.data);\n                    return;\n                }\n                break;\n        }\n        task.promiseRejecter(new Error(`unexpected response type: ${response.type.toString()}`));\n    }\n\n    /** Received an error */\n    protected onError(event: ErrorEvent): void {\n        console.error(event);\n        console.error(`error in duckdb worker: ${event.message}`);\n        this._pendingRequests.clear();\n    }\n\n    /** The worker was closed */\n    protected onClose(): void {\n        this._workerShutdownResolver(null);\n        if (this._pendingRequests.size != 0) {\n            console.warn(`worker terminated with ${this._pendingRequests.size} pending requests`);\n            return;\n        }\n        this._pendingRequests.clear();\n    }\n\n    /** Reset the duckdb */\n    public async reset(): Promise<null> {\n        const task = new WorkerTask<WorkerRequestType.RESET, null, null>(WorkerRequestType.RESET, null);\n        return await this.postTask(task);\n    }\n\n    /** Ping the worker thread */\n    public async ping(): Promise<any> {\n        const task = new WorkerTask<WorkerRequestType.PING, null, null>(WorkerRequestType.PING, null);\n        await this.postTask(task);\n    }\n    /** Try to drop a file */\n    public async dropFile(name: string): Promise<boolean> {\n        const task = new WorkerTask<WorkerRequestType.DROP_FILE, string, boolean>(WorkerRequestType.DROP_FILE, name);\n        return await this.postTask(task);\n    }\n    /** Try to drop files */\n    public async dropFiles(): Promise<null> {\n        const task = new WorkerTask<WorkerRequestType.DROP_FILES, null, null>(WorkerRequestType.DROP_FILES, null);\n        return await this.postTask(task);\n    }\n    /** Flush all files */\n    public async flushFiles(): Promise<null> {\n        const task = new WorkerTask<WorkerRequestType.FLUSH_FILES, null, null>(WorkerRequestType.FLUSH_FILES, null);\n        return await this.postTask(task);\n    }\n\n    /** Open the database */\n    public async instantiate(mainModuleURL: string, pthreadWorkerURL: string | null = null): Promise<null> {\n        const task = new WorkerTask<WorkerRequestType.INSTANTIATE, [string, string | null], null>(\n            WorkerRequestType.INSTANTIATE,\n            [mainModuleURL, pthreadWorkerURL],\n        );\n        return await this.postTask(task);\n    }\n\n    /** Get the version */\n    public async getVersion(): Promise<string> {\n        const task = new WorkerTask<WorkerRequestType.GET_VERSION, null, string>(WorkerRequestType.GET_VERSION, null);\n        const version = await this.postTask(task);\n        return version;\n    }\n\n    /** Get the feature flags */\n    public async getFeatureFlags(): Promise<number> {\n        const task = new WorkerTask<WorkerRequestType.GET_FEATURE_FLAGS, null, number>(\n            WorkerRequestType.GET_FEATURE_FLAGS,\n            null,\n        );\n        const feature = await this.postTask(task);\n        return feature;\n    }\n\n    /** Open a new database */\n    public async open(config: DuckDBConfig): Promise<void> {\n        const task = new WorkerTask<WorkerRequestType.OPEN, DuckDBConfig, null>(WorkerRequestType.OPEN, config);\n        await this.postTask(task);\n    }\n\n    /** Tokenize a script text */\n    public async tokenize(text: string): Promise<ScriptTokens> {\n        const task = new WorkerTask<WorkerRequestType.TOKENIZE, string, ScriptTokens>(WorkerRequestType.TOKENIZE, text);\n        const tokens = await this.postTask(task);\n        return tokens;\n    }\n\n    /** Connect to the database */\n    public async connectInternal(): Promise<number> {\n        const task = new WorkerTask<WorkerRequestType.CONNECT, null, ConnectionID>(WorkerRequestType.CONNECT, null);\n        return await this.postTask(task);\n    }\n\n    /** Connect to the database */\n    public async connect(): Promise<AsyncDuckDBConnection> {\n        const cid = await this.connectInternal();\n        return new AsyncDuckDBConnection(this, cid);\n    }\n\n    /** Disconnect from the database */\n    public async disconnect(conn: ConnectionID): Promise<void> {\n        const task = new WorkerTask<WorkerRequestType.DISCONNECT, ConnectionID, null>(\n            WorkerRequestType.DISCONNECT,\n            conn,\n        );\n        await this.postTask(task);\n    }\n\n    /** Run a query */\n    public async runQuery(conn: ConnectionID, text: string): Promise<Uint8Array> {\n        const task = new WorkerTask<WorkerRequestType.RUN_QUERY, [ConnectionID, string], Uint8Array>(\n            WorkerRequestType.RUN_QUERY,\n            [conn, text],\n        );\n        return await this.postTask(task);\n    }\n\n    /** Send a query */\n    public async sendQuery(conn: ConnectionID, text: string): Promise<Uint8Array> {\n        const task = new WorkerTask<WorkerRequestType.SEND_QUERY, [ConnectionID, string], Uint8Array>(\n            WorkerRequestType.SEND_QUERY,\n            [conn, text],\n        );\n        return await this.postTask(task);\n    }\n\n    /** Fetch query results */\n    public async fetchQueryResults(conn: ConnectionID): Promise<Uint8Array> {\n        const task = new WorkerTask<WorkerRequestType.FETCH_QUERY_RESULTS, ConnectionID, Uint8Array>(\n            WorkerRequestType.FETCH_QUERY_RESULTS,\n            conn,\n        );\n        return await this.postTask(task);\n    }\n\n    /** Prepare a statement and return its identifier */\n    public async createPrepared(conn: number, text: string): Promise<number> {\n        const task = new WorkerTask<WorkerRequestType.CREATE_PREPARED, [number, string], number>(\n            WorkerRequestType.CREATE_PREPARED,\n            [conn, text],\n        );\n        return await this.postTask(task);\n    }\n    /** Close a prepared statement */\n    public async closePrepared(conn: number, statement: number): Promise<void> {\n        const task = new WorkerTask<WorkerRequestType.CLOSE_PREPARED, [number, number], null>(\n            WorkerRequestType.CLOSE_PREPARED,\n            [conn, statement],\n        );\n        await this.postTask(task);\n    }\n    /** Execute a prepared statement and return the full result */\n    public async runPrepared(conn: number, statement: number, params: any[]): Promise<Uint8Array> {\n        const task = new WorkerTask<WorkerRequestType.RUN_PREPARED, [ConnectionID, number, any[]], Uint8Array>(\n            WorkerRequestType.RUN_PREPARED,\n            [conn, statement, params],\n        );\n        return await this.postTask(task);\n    }\n    /** Execute a prepared statement and stream the result */\n    public async sendPrepared(conn: number, statement: number, params: any[]): Promise<Uint8Array> {\n        const task = new WorkerTask<WorkerRequestType.SEND_PREPARED, [ConnectionID, number, any[]], Uint8Array>(\n            WorkerRequestType.SEND_PREPARED,\n            [conn, statement, params],\n        );\n        return await this.postTask(task);\n    }\n    /** Glob file infos */\n    public async globFiles(path: string): Promise<WebFile[]> {\n        const task = new WorkerTask<WorkerRequestType.GLOB_FILE_INFOS, string, WebFile[]>(\n            WorkerRequestType.GLOB_FILE_INFOS,\n            path,\n        );\n        return await this.postTask(task);\n    }\n    /** Register file text */\n    public async registerFileText(name: string, text: string): Promise<void> {\n        const buffer = TEXT_ENCODER.encode(text);\n        await this.registerFileBuffer(name, buffer);\n    }\n    /** Register a file path. */\n    public async registerFileURL(name: string, url: string): Promise<void> {\n        if (url === undefined) {\n            url = name;\n        }\n        const task = new WorkerTask<WorkerRequestType.REGISTER_FILE_URL, [string, string], null>(\n            WorkerRequestType.REGISTER_FILE_URL,\n            [name, url],\n        );\n        await this.postTask(task);\n    }\n\n    /** Register an empty file buffer. */\n    public async registerEmptyFileBuffer(name: string): Promise<void> {\n        const task = new WorkerTask<WorkerRequestType.REGISTER_FILE_BUFFER, [string, Uint8Array], null>(\n            WorkerRequestType.REGISTER_FILE_BUFFER,\n            [name, new Uint8Array()],\n        );\n        await this.postTask(task);\n    }\n\n    /** Register a file buffer. */\n    public async registerFileBuffer(name: string, buffer: Uint8Array): Promise<void> {\n        const task = new WorkerTask<WorkerRequestType.REGISTER_FILE_BUFFER, [string, Uint8Array], null>(\n            WorkerRequestType.REGISTER_FILE_BUFFER,\n            [name, buffer],\n        );\n        await this.postTask(task, [buffer.buffer]);\n    }\n\n    /** Register a file handle. */\n    public async registerFileHandle<HandleType>(name: string, handle: HandleType): Promise<void> {\n        const task = new WorkerTask<WorkerRequestType.REGISTER_FILE_HANDLE, [string, any], null>(\n            WorkerRequestType.REGISTER_FILE_HANDLE,\n            [name, handle],\n        );\n        await this.postTask(task, []);\n    }\n\n    /** Enable file statistics */\n    public async collectFileStatistics(name: string, enable: boolean): Promise<void> {\n        const task = new WorkerTask<WorkerRequestType.COLLECT_FILE_STATISTICS, [string, boolean], null>(\n            WorkerRequestType.COLLECT_FILE_STATISTICS,\n            [name, enable],\n        );\n        await this.postTask(task, []);\n    }\n\n    /** Export file statistics */\n    public async exportFileStatistics(name: string): Promise<FileStatistics> {\n        const task = new WorkerTask<WorkerRequestType.EXPORT_FILE_STATISTICS, string, FileStatistics>(\n            WorkerRequestType.EXPORT_FILE_STATISTICS,\n            name,\n        );\n        return await this.postTask(task, []);\n    }\n\n    /** Copy a file to a buffer. */\n    public async copyFileToBuffer(name: string): Promise<Uint8Array> {\n        const task = new WorkerTask<WorkerRequestType.COPY_FILE_TO_BUFFER, string, Uint8Array>(\n            WorkerRequestType.COPY_FILE_TO_BUFFER,\n            name,\n        );\n        return await this.postTask(task);\n    }\n\n    /** Copy a file to a path. */\n    public async copyFileToPath(name: string, path: string): Promise<void> {\n        const task = new WorkerTask<WorkerRequestType.COPY_FILE_TO_PATH, [string, string], null>(\n            WorkerRequestType.COPY_FILE_TO_PATH,\n            [name, path],\n        );\n        await this.postTask(task);\n    }\n\n    /** Insert arrow from an ipc stream */\n    public async insertArrowFromIPCStream(\n        conn: ConnectionID,\n        buffer: Uint8Array,\n        options?: ArrowInsertOptions,\n    ): Promise<void> {\n        // Pass to the worker\n        const task = new WorkerTask<\n            WorkerRequestType.INSERT_ARROW_FROM_IPC_STREAM,\n            [number, Uint8Array, ArrowInsertOptions | undefined],\n            null\n        >(WorkerRequestType.INSERT_ARROW_FROM_IPC_STREAM, [conn, buffer, options]);\n        await this.postTask(task, [buffer.buffer]);\n    }\n    /** Insert a csv file */\n    public async insertCSVFromPath(conn: ConnectionID, path: string, options: CSVInsertOptions): Promise<void> {\n        // Flatten the table options\n        if (options.columns !== undefined) {\n            const out = [];\n            for (const k in options.columns) {\n                const type = options.columns[k];\n                out.push(flattenArrowField(k, type));\n            }\n            options.columnsFlat = out;\n            delete options.columns;\n        }\n\n        // Pass to the worker\n        const task = new WorkerTask<WorkerRequestType.INSERT_CSV_FROM_PATH, [number, string, CSVInsertOptions], null>(\n            WorkerRequestType.INSERT_CSV_FROM_PATH,\n            [conn, path, options],\n        );\n        await this.postTask(task);\n    }\n    /** Insert a json file */\n    public async insertJSONFromPath(conn: ConnectionID, path: string, options: JSONInsertOptions): Promise<void> {\n        // Flatten the table options\n        if (options.columns !== undefined) {\n            const out = [];\n            for (const k in options.columns) {\n                const type = options.columns[k];\n                out.push(flattenArrowField(k, type));\n            }\n            options.columnsFlat = out;\n            delete options.columns;\n        }\n\n        // Pass to the worker\n        const task = new WorkerTask<WorkerRequestType.INSERT_JSON_FROM_PATH, [number, string, JSONInsertOptions], null>(\n            WorkerRequestType.INSERT_JSON_FROM_PATH,\n            [conn, path, options],\n        );\n        await this.postTask(task);\n    }\n}\n", "import { DuckDBBindings } from '../bindings';\nimport { WorkerResponseVariant, WorkerRequestVariant, WorkerRequestType, WorkerResponseType } from './worker_request';\nimport { Logger, LogEntryVariant } from '../log';\n\nexport abstract class AsyncDuckDBDispatcher implements Logger {\n    /** The bindings */\n    protected _bindings: DuckDBBindings | null = null;\n    /** The next message id */\n    protected _nextMessageId = 0;\n\n    /** Instantiate the wasm module */\n    protected abstract instantiate(mainModule: string, pthreadWorker: string | null): Promise<DuckDBBindings>;\n    /** Post a response to the main thread */\n    protected abstract postMessage(response: WorkerResponseVariant, transfer: ArrayBuffer[]): void;\n\n    /** Send log entry to the main thread */\n    public log(entry: LogEntryVariant): void {\n        this.postMessage(\n            {\n                messageId: this._nextMessageId++,\n                requestId: 0,\n                type: WorkerResponseType.LOG,\n                data: entry,\n            },\n            [],\n        );\n    }\n\n    /** Send plain OK without further data */\n    protected sendOK(request: WorkerRequestVariant): void {\n        this.postMessage(\n            {\n                messageId: this._nextMessageId++,\n                requestId: request.messageId,\n                type: WorkerResponseType.OK,\n                data: null,\n            },\n            [],\n        );\n    }\n\n    /** Fail with an error */\n    protected failWith(request: WorkerRequestVariant, e: Error): void {\n        // Workaround for Firefox not being able to perform structured-clone on Native Errors\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1556604\n        const obj: any = {\n            name: e.name,\n            message: e.message,\n            stack: e.stack || undefined,\n        };\n        this.postMessage(\n            {\n                messageId: this._nextMessageId++,\n                requestId: request.messageId,\n                type: WorkerResponseType.ERROR,\n                data: obj,\n            },\n            [],\n        );\n        return;\n    }\n\n    /** Process a request from the main thread */\n    public async onMessage(request: WorkerRequestVariant): Promise<void> {\n        // First process those requests that don't need bindings\n        switch (request.type) {\n            case WorkerRequestType.PING:\n                this.sendOK(request);\n                return;\n            case WorkerRequestType.INSTANTIATE:\n                if (this._bindings != null) {\n                    this.failWith(request, new Error('duckdb already initialized'));\n                }\n                try {\n                    this._bindings = await this.instantiate(request.data[0], request.data[1]);\n                    this.sendOK(request);\n                } catch (e: any) {\n                    this._bindings = null;\n                    this.failWith(request, e);\n                }\n                return;\n            default:\n                break;\n        }\n\n        // Bindings not initialized?\n        if (!this._bindings) {\n            return this.failWith(request, new Error('duckdb is not initialized'));\n        }\n\n        // Catch every exception and forward it as error message to the main thread\n        try {\n            switch (request.type) {\n                case WorkerRequestType.GET_VERSION:\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.VERSION_STRING,\n                            data: this._bindings.getVersion(),\n                        },\n                        [],\n                    );\n                    break;\n                case WorkerRequestType.GET_FEATURE_FLAGS:\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.FEATURE_FLAGS,\n                            data: this._bindings.getFeatureFlags(),\n                        },\n                        [],\n                    );\n                    break;\n                case WorkerRequestType.RESET:\n                    this._bindings.reset();\n                    this.sendOK(request);\n                    break;\n\n                case WorkerRequestType.OPEN:\n                    this._bindings.open(request.data);\n                    this.sendOK(request);\n                    break;\n                case WorkerRequestType.DROP_FILE:\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.SUCCESS,\n                            data: this._bindings.dropFile(request.data),\n                        },\n                        [],\n                    );\n                    break;\n                case WorkerRequestType.DROP_FILES:\n                    this._bindings.dropFiles();\n                    this.sendOK(request);\n                    break;\n                case WorkerRequestType.FLUSH_FILES:\n                    this._bindings.flushFiles();\n                    this.sendOK(request);\n                    break;\n                case WorkerRequestType.CONNECT: {\n                    const conn = this._bindings.connect();\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.CONNECTION_INFO,\n                            data: conn.useUnsafe((_, c) => c),\n                        },\n                        [],\n                    );\n                    break;\n                }\n                case WorkerRequestType.DISCONNECT:\n                    this._bindings.disconnect(request.data);\n                    this.sendOK(request);\n                    break;\n                case WorkerRequestType.CREATE_PREPARED: {\n                    const result = this._bindings.createPrepared(request.data[0], request.data[1]);\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.PREPARED_STATEMENT_ID,\n                            data: result,\n                        },\n                        [],\n                    );\n                    break;\n                }\n                case WorkerRequestType.CLOSE_PREPARED: {\n                    this._bindings.closePrepared(request.data[0], request.data[1]);\n                    this.sendOK(request);\n                    break;\n                }\n                case WorkerRequestType.RUN_PREPARED: {\n                    const result = this._bindings.runPrepared(request.data[0], request.data[1], request.data[2]);\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.QUERY_RESULT,\n                            data: result,\n                        },\n                        [result.buffer],\n                    );\n                    break;\n                }\n                case WorkerRequestType.RUN_QUERY: {\n                    const result = this._bindings.runQuery(request.data[0], request.data[1]);\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.QUERY_RESULT,\n                            data: result,\n                        },\n                        [result.buffer],\n                    );\n                    break;\n                }\n                case WorkerRequestType.SEND_PREPARED: {\n                    const result = this._bindings.sendPrepared(request.data[0], request.data[1], request.data[2]);\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.QUERY_START,\n                            data: result,\n                        },\n                        [result.buffer],\n                    );\n                    break;\n                }\n                case WorkerRequestType.SEND_QUERY: {\n                    const result = this._bindings.sendQuery(request.data[0], request.data[1]);\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.QUERY_START,\n                            data: result,\n                        },\n                        [result.buffer],\n                    );\n                    break;\n                }\n                case WorkerRequestType.FETCH_QUERY_RESULTS: {\n                    const result = this._bindings.fetchQueryResults(request.data);\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.QUERY_RESULT_CHUNK,\n                            data: result,\n                        },\n                        [result.buffer],\n                    );\n                    break;\n                }\n                case WorkerRequestType.GLOB_FILE_INFOS: {\n                    const infos = this._bindings.globFiles(request.data);\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.FILE_INFOS,\n                            data: infos,\n                        },\n                        [],\n                    );\n                    break;\n                }\n\n                case WorkerRequestType.REGISTER_FILE_URL:\n                    this._bindings.registerFileURL(request.data[0], request.data[1]);\n                    this.sendOK(request);\n                    break;\n\n                case WorkerRequestType.REGISTER_FILE_BUFFER:\n                    this._bindings.registerFileBuffer(request.data[0], request.data[1]);\n                    this.sendOK(request);\n                    break;\n\n                case WorkerRequestType.REGISTER_FILE_HANDLE:\n                    this._bindings.registerFileHandle(request.data[0], request.data[1]);\n                    this.sendOK(request);\n                    break;\n\n                case WorkerRequestType.COPY_FILE_TO_PATH:\n                    this._bindings.copyFileToPath(request.data[0], request.data[1]);\n                    this.sendOK(request);\n                    break;\n\n                case WorkerRequestType.COPY_FILE_TO_BUFFER: {\n                    const buffer = this._bindings.copyFileToBuffer(request.data);\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.FILE_BUFFER,\n                            data: buffer,\n                        },\n                        [],\n                    );\n                    break;\n                }\n                case WorkerRequestType.COLLECT_FILE_STATISTICS:\n                    this._bindings.collectFileStatistics(request.data[0], request.data[1]);\n                    this.sendOK(request);\n                    break;\n\n                case WorkerRequestType.EXPORT_FILE_STATISTICS: {\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.FILE_STATISTICS,\n                            data: this._bindings.exportFileStatistics(request.data),\n                        },\n                        [],\n                    );\n                    break;\n                }\n                case WorkerRequestType.INSERT_ARROW_FROM_IPC_STREAM: {\n                    this._bindings.insertArrowFromIPCStream(request.data[0], request.data[1], request.data[2]);\n                    this.sendOK(request);\n                    break;\n                }\n                case WorkerRequestType.INSERT_CSV_FROM_PATH: {\n                    this._bindings.insertCSVFromPath(request.data[0], request.data[1], request.data[2]);\n                    this.sendOK(request);\n                    break;\n                }\n                case WorkerRequestType.INSERT_JSON_FROM_PATH: {\n                    this._bindings.insertJSONFromPath(request.data[0], request.data[1], request.data[2]);\n                    this.sendOK(request);\n                    break;\n                }\n                case WorkerRequestType.TOKENIZE: {\n                    const result = this._bindings.tokenize(request.data);\n                    this.postMessage(\n                        {\n                            messageId: this._nextMessageId++,\n                            requestId: request.messageId,\n                            type: WorkerResponseType.SCRIPT_TOKENS,\n                            data: result,\n                        },\n                        [],\n                    );\n                    break;\n                }\n            }\n        } catch (e: any) {\n            return this.failWith(request, e);\n        }\n    }\n}\n", "import * as check from 'wasm-feature-detect';\nimport { PACKAGE_NAME, PACKAGE_VERSION } from './version';\n\nexport interface DuckDBBundles {\n    asyncDefault: {\n        mainModule: string;\n        mainWorker: string;\n    };\n    asyncNext?: {\n        mainModule: string;\n        mainWorker: string;\n    };\n    asyncNextCOI?: {\n        mainModule: string;\n        mainWorker: string;\n        pthreadWorker: string;\n    };\n}\n\nfunction getWorkerURL(url: string) {\n    const content = `importScripts(\"${url}\");`;\n    return URL.createObjectURL(new Blob([content], { type: 'text/javascript' }));\n}\n\nexport function getJsDelivrBundles(): DuckDBBundles {\n    const jsdelivr_dist_url = `https://cdn.jsdelivr.net/npm/${PACKAGE_NAME}@${PACKAGE_VERSION}/dist/`;\n    return {\n        asyncDefault: {\n            mainModule: `${jsdelivr_dist_url}duckdb.wasm`,\n            mainWorker: getWorkerURL(`${jsdelivr_dist_url}duckdb-browser-async.worker.js`),\n        },\n        asyncNext: {\n            mainModule: `${jsdelivr_dist_url}duckdb-next.wasm`,\n            mainWorker: getWorkerURL(`${jsdelivr_dist_url}duckdb-browser-async-next.worker.js`),\n        },\n        asyncNextCOI: {\n            mainModule: `${jsdelivr_dist_url}duckdb-next-coi.wasm`,\n            mainWorker: getWorkerURL(`${jsdelivr_dist_url}duckdb-browser-async-next-coi.worker.js`),\n            pthreadWorker: getWorkerURL(`${jsdelivr_dist_url}duckdb-browser-async-next-coi.pthread.worker.js`),\n        },\n    };\n}\n\nexport interface DuckDBBundle {\n    mainModule: string;\n    mainWorker: string | null;\n    pthreadWorker: string | null;\n}\n\nexport interface PlatformFeatures {\n    bigInt64Array: boolean;\n    crossOriginIsolated: boolean;\n    wasmExceptions: boolean;\n    wasmSIMD: boolean;\n    wasmBulkMemory: boolean;\n    wasmThreads: boolean;\n}\n\nlet bigInt64Array: boolean | null = null;\nlet wasmExceptions: boolean | null = null;\nlet wasmThreads: boolean | null = null;\nlet wasmSIMD: boolean | null = null;\nlet wasmBulkMemory: boolean | null = null;\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\ndeclare namespace globalThis {\n    let crossOriginIsolated: boolean;\n}\n\nfunction isNode(): boolean {\n    return typeof process !== 'undefined' && process.release.name === 'node';\n}\n\nexport async function getPlatformFeatures(): Promise<PlatformFeatures> {\n    if (bigInt64Array == null) {\n        bigInt64Array = typeof BigInt64Array != 'undefined';\n    }\n    if (wasmExceptions == null) {\n        wasmExceptions = await check.exceptions();\n    }\n    if (wasmThreads == null) {\n        wasmThreads = await check.threads();\n    }\n    if (wasmSIMD == null) {\n        wasmSIMD = await check.simd();\n    }\n    if (wasmBulkMemory == null) {\n        wasmBulkMemory = await check.bulkMemory();\n    }\n    return {\n        bigInt64Array: bigInt64Array!,\n        crossOriginIsolated: isNode() || globalThis.crossOriginIsolated || false,\n        wasmExceptions: wasmExceptions!,\n        wasmSIMD: wasmSIMD!,\n        wasmThreads: wasmThreads!,\n        wasmBulkMemory: wasmBulkMemory!,\n    };\n}\n\nexport async function selectBundle(bundles: DuckDBBundles): Promise<DuckDBBundle> {\n    const platform = await getPlatformFeatures();\n    if (platform.wasmExceptions && platform.wasmSIMD) {\n        if (platform.wasmThreads && platform.crossOriginIsolated && bundles.asyncNextCOI) {\n            return {\n                mainModule: bundles.asyncNextCOI.mainModule,\n                mainWorker: bundles.asyncNextCOI.mainWorker,\n                pthreadWorker: bundles.asyncNextCOI.pthreadWorker,\n            };\n        }\n        if (bundles.asyncNext) {\n            return {\n                mainModule: bundles.asyncNext.mainModule,\n                mainWorker: bundles.asyncNext.mainWorker,\n                pthreadWorker: null,\n            };\n        }\n    }\n    return {\n        mainModule: bundles.asyncDefault.mainModule,\n        mainWorker: bundles.asyncDefault.mainWorker,\n        pthreadWorker: null,\n    };\n}\n", "import config from '../package.json';\n\nexport const PACKAGE_NAME = config.name;\nexport const PACKAGE_VERSION = config.version;\n\nconst VERSION_PARTS = config.version.split('.');\nexport const PACKAGE_VERSION_MAJOR = VERSION_PARTS[0];\nexport const PACKAGE_VERSION_MINOR = VERSION_PARTS[1];\nexport const PACKAGE_VERSION_PATCH = VERSION_PARTS[2];\n"],
  "mappings": "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",
  "names": []
}
